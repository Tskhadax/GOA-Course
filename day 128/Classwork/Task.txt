// ასინქრონიზირებული კოდის დროს return- ში რაც გვეწერება ეგ არ დაბრუნბდება. მარტივი გამოსავავალია callBack. და Promise 

// promise 
// promise იყოფა ორ ნაწილად. პირველი არის ვინც ქმნის პირობას, მეორე არის ის ვინც იღებს. ვისაც ეხება.

promise რომ შევქმნათ აუცილებლად უნდა დავწეროთ new დამხმარე სიტყვა, შემდეგ Promise() -ამით ვქმნით. გამოძახება არის მიმღები


function maker() {
    return new Promise(resolve, reject){  //შემქმნელი
        resolve('Snow')
    }
}

maker() //მიმღები

* Promise()-ს გადაეცემა ორი არგუმენტი. ერთი არის resolve და reject.
* resolve-ში როცა შესრულდება წარმატებით, 
* მეორე უარყოფილია. 
* ერთ-ერთი უნდა იყოს გამოძახებული ორივე არა. 
* თუ არც ერთი ხდება მაშინ დალოდების პროცესშია.
* პარამეტრებს რა ერქმევა არ აქვს მნიშვნელობა. თანმიმდევრობა არის აუცილებელი


// მეორე ვარიანტი ცვლადში შენახვა

function maker() {
    return new Promise(resolve, reject){  //შემქმნელი
        resolve('Snow')
    }
}


let newValue = maker() // მიმღები
newValue.then( function (data){
    console.log(data)
})


// then() -შემდეგ, აქ ვწერთ ანონიმუს ფუნქცია სადაც იწერება რა უნდა შესრულდეს გამოძახების შემდეგ. კიდევ ფუნქცია შეიძლება გადავცეთ, ორიარგუმენტიც. პირველი არგუმენტი resolve თვის იქნება. და მეორე იქნება reject-ის იქნება. 